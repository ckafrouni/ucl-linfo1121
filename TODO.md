# TodoList

## Exercises

* ConnectedComponents (Graphs)

Why it's useful: Understanding connected components is crucial in graph theory. It's foundational for network
analysis, understanding graph connectivity, and can be applied in various fields like social network analysis,
biology, and computer network design.

* BreadthFirstShortestPaths (Graphs)

Why it's useful: This exercise will help you understand breadth-first search (BFS), a fundamental graph traversal
technique. BFS is widely used in computing the shortest paths in unweighted graphs and has applications in various
algorithms, including solving puzzles and network routing.

* RedBlackTreeConverter (Searching)

Why it's useful: Red-Black Trees are a self-balancing BST variant. Understanding them is crucial for efficient data
storage and retrieval operations. They are used in many real-world applications, including the implementation of
several associative containers in the C++ STL and Java TreeMap.

* LRUCache (Searching)

Why it's useful: Implementing an LRU (Least Recently Used) Cache is a common problem in software engineering
interviews. It also has practical applications in designing systems that require quick data retrieval with a
constraint on memory size.

* RabinKarp (Strings)

Why it's useful: The Rabin-Karp algorithm is an efficient string searching method. It's particularly useful for
detecting plagiarism and in various applications where a fast and reliable string matching algorithm is required.

* GlobalWarmingPaths (Graphs)

Why it's useful: This likely involves complex graph-based problem-solving with real-world applications in
environmental modeling, simulation, and analysis. It could also involve path finding or optimization algorithms,
which are key concepts in computer science.

---

### Priority Queues

* [ ] Implementation
* [ ] Complexity

A priority queue is a special type of queue data structure where each element is associated with a
priority. The priority of the elements in a priority queue determines the deletion order. The element with the
highest priority is deleted first. In case elements have the same priority, they are served according to their
ordering in the queue.

---

### Rabin-Karp implementation

* [ ] Incremental Hash Algorithm (Rolling hash ?)

[Rolling hash | Rabin karp algorithm | Pattern searching](https://www.youtube.com/watch?v=BQ9E-2umSWc)

---

### Binary Heap (MinHeap)

* [x] insertion
* [ ] deletion
    * [ ] pop

---

### MinMax Heap

* [X] Insertion
* [ ] Deletion
    * [ ] popMin
    * [ ] popMax

---

### HashTable

[Hash table linear probing](https://www.youtube.com/watch?v=Ma9XOInZJWM)